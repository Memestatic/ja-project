@page "/fir"
@using System.Diagnostics
@rendermode InteractiveServer
@inject IJSRuntime _js

<PageTitle>FIR</PageTitle>

<div class="container mt-4">
    <h1 class="mb-4">FIR low pass filter</h1>

    <InputFile OnChange="HandleFileSelected" MaxFileSize="5242880" />
    <button @onclick="Start" disabled="@isFileNotSelected">Apply FIR Filter</button>

    @if (!string.IsNullOrEmpty(audioSrc))
    {
        <div class="card bg-light mt-5 p-2 w-50">
            <h4>Filtered Audio:</h4>
            <audio controls>
                <source src="@audioSrc" type="audio/wav" />
                Your browser does not support the audio element.
            </audio>
        </div>
    }

    <p>
        Czas wykonania algorytmu: @timeResult
    </p>
    
</div>


@code {
    double timeResult = 0;
    private IBrowserFile selectedFile;
    private bool isFileNotSelected = true;
    private string audioSrc; // Ścieżka do przefiltrowanego dźwięku

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        Console.WriteLine("File selected");
        selectedFile = e.File;
        isFileNotSelected = selectedFile == null || selectedFile.ContentType != "audio/wav"; // Dodano sprawdzenie typu pliku
        StateHasChanged();
    }


    private async Task Start()
    {
        if (selectedFile == null)
        {
            Console.WriteLine("No file selected.");
            return;
        }

        try
        {
            const int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];

            Stopwatch stopwatch = new();

            using (var stream = selectedFile.OpenReadStream(5 * 1024 * 1024))
            {
                using (var ms = new MemoryStream(5 * 1024 * 1024))
                {
                    int bytesRead;
                    List<Task<byte[]>> processingTasks = new List<Task<byte[]>>();

                    while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                    {
                        byte[] audioChunk = new byte[bytesRead];
                        Array.Copy(buffer, audioChunk, bytesRead);

                        // Przetwarzaj każdy bufor asynchronicznie
                        processingTasks.Add(ProcessFIRFilter(audioChunk));
                    }

                    stopwatch.Start();
                    byte[][] processedChunks = await Task.WhenAll(processingTasks);
                    stopwatch.Stop();

                    timeResult = stopwatch.Elapsed.TotalNanoseconds;

                    StateHasChanged();

                    // Połącz przetworzone bufory
                    foreach (var chunk in processedChunks)
                    {
                        ms.Write(chunk, 0, chunk.Length);
                    }

                    byte[] filteredAudioData = ms.ToArray();

                    audioSrc = $"data:audio/wav;base64,{Convert.ToBase64String(filteredAudioData)}";

                    Console.WriteLine("Original audio data size: " + filteredAudioData.Length);
                    Console.WriteLine("Base64 encoded audio data size: " + audioSrc.Length);

                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
        }
    }

    private Task<byte[]> ProcessFIRFilter(byte[] audioData)
	{
        return Task.FromResult(audioData);
	}

}
