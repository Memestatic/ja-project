@page "/fir"
@using System.Diagnostics
@rendermode InteractiveServer
@inject IJSRuntime _js

<PageTitle>FIR</PageTitle>


<div class="card card-body m-5 w-50">
    <h1 class="mb-4">FIR Low Pass Filter</h1>

    <InputFile OnChange="HandleFileSelected" MaxFileSize="5242880" />

    <div class="mt-3">
        <h5>Select the number of threads:</h5>
        <div class="btn-group me-2 mt-2" role="group">
            <button type="button" class="btn btn-primary" @onclick="() => SetThreadCount(1)">1</button>
            <button type="button" class="btn btn-primary" @onclick="() => SetThreadCount(2)">2</button>
            <button type="button" class="btn btn-primary" @onclick="() => SetThreadCount(4)">4</button>
            <button type="button" class="btn btn-primary" @onclick="() => SetThreadCount(maxThreads)">@maxThreads</button>
        </div>
    </div>

    <button class="btn btn-success mt-3" @onclick="Start" disabled="@isFileNotSelected">Apply FIR Filter</button>
</div>

@if (!string.IsNullOrEmpty(audioSrc))
{
    <div class="card bg-light mt-5 p-3 w-75">
        <h4>Filtered Audio:</h4>
        <audio controls class="w-100">
            <source src="@audioSrc" type="audio/wav" />
            Your browser does not support the audio element.
        </audio>
        
        <p class="mt-3">
            Czas wykonania algorytmu: @timeResult ms
        </p>
    </div>
}




@code {
    double timeResult = 0;
    private IBrowserFile selectedFile;
    private bool isFileNotSelected = true;
    private string audioSrc; // Ścieżka do przefiltrowanego dźwięku
    private int threadCount = 1; // Domyślna liczba wątków
    private int maxThreads = Environment.ProcessorCount; // Maksymalna liczba wątków

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        Console.WriteLine("File selected");
        selectedFile = e.File;
        isFileNotSelected = selectedFile == null || selectedFile.ContentType != "audio/wav"; // Dodano sprawdzenie typu pliku
        StateHasChanged();
    }

    private void SetThreadCount(int count)
    {
        threadCount = count;
        StateHasChanged();
    }

    private async Task Start()
    {
        if (selectedFile == null)
        {
            Console.WriteLine("No file selected.");
            return;
        }

        try
        {
            const int bufferSize = 8192;
            byte[] buffer = new byte[bufferSize];

            Stopwatch stopwatch = new();

            using (var stream = selectedFile.OpenReadStream(5 * 1024 * 1024))
            {
                using (var ms = new MemoryStream(5 * 1024 * 1024))
                {
                    int bytesRead;
                    List<byte[]> processedChunks = new List<byte[]>();
                    List<Thread> threads = new List<Thread>();

                    stopwatch.Start();

                    while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                    {
                        byte[] audioChunk = new byte[bytesRead];
                        Array.Copy(buffer, audioChunk, bytesRead);

                        // Tworzenie i uruchamianie wątków
                        var thread = new Thread(() =>
                        {
                            var processedChunk = ProcessFIRFilter(audioChunk);
                            lock (processedChunks)
                            {
                                processedChunks.Add(processedChunk);
                            }
                        });

                        threads.Add(thread);
                        thread.Start();

                        if (threads.Count >= threadCount)
                        {
                            foreach (var t in threads)
                            {
                                t.Join();
                            }
                            threads.Clear();
                        }
                    }

                    foreach (var t in threads)
                    {
                        t.Join();
                    }

                    stopwatch.Stop();

                    timeResult = stopwatch.Elapsed.TotalMilliseconds;

                    StateHasChanged();

                    // Połącz przetworzone bufory
                    foreach (var chunk in processedChunks)
                    {
                        ms.Write(chunk, 0, chunk.Length);
                    }

                    byte[] filteredAudioData = ms.ToArray();

                    audioSrc = $"data:audio/wav;base64,{Convert.ToBase64String(filteredAudioData)}";

                    Console.WriteLine("Original audio data size: " + filteredAudioData.Length);
                    Console.WriteLine("Base64 encoded audio data size: " + audioSrc.Length);

                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
        }
    }

    private byte[] ProcessFIRFilter(byte[] audioData)
    {
        return audioData; // Pusty algorytm, tylko zwraca dane
    }
}